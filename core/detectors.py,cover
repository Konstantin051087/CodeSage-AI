> import libcst as cst
> from libcst import CSTVisitor, Name, Attribute, Call
> from libcst.metadata import PositionProvider
  
> class SQLInjectionDetector(CSTVisitor):
>     METADATA_DEPENDENCIES = (PositionProvider,)
  
>     def __init__(self):
>         self.vulnerabilities = []
  
>     def visit_Call(self, node: cst.Call):
>         if (
>             isinstance(node.func, cst.Attribute) and
>             node.func.attr.value == "execute"
>         ):
              # 2+ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð² â€” ÑÐºÐ¾Ñ€ÐµÐµ Ð²ÑÐµÐ³Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ (Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾)
>             if len(node.args) >= 2:
>                 return
  
              # 0 Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð² â€” Ð½ÐµÑ‡ÐµÐ³Ð¾ Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ
>             if len(node.args) == 0:
>                 return
  
>             query_arg = node.args[0].value
>             if self._is_dangerous_sql_expression(query_arg):
>                 pos = self.get_metadata(PositionProvider, node).start
>                 self.vulnerabilities.append({
>                     "type": "sql_injection",
>                     "file": "current_file",
>                     "line": pos.line,
>                     "code": self._get_code_snippet(node),
>                     "fix": self._generate_fix(node)
>                 })
  
>     def _is_dangerous_sql_expression(self, node: cst.BaseExpression) -> bool:
>         if isinstance(node, cst.FormattedString):
>             return True
>         if isinstance(node, cst.BinaryOperation):
>             return isinstance(node.operator, (cst.Add, cst.Modulo))
>         if isinstance(node, cst.SimpleString):
>             return False
>         return False
  
>     def _get_code_snippet(self, node: cst.Call) -> str:
>         return cst.Module([]).code_for_node(node)
  
>     def _generate_fix(self, node: cst.Call) -> str:
>         return (
>             "# Ð’Ð¼ÐµÑÑ‚Ð¾:\n"
>             "# cursor.execute(f\"SELECT * FROM users WHERE name = {name}\")\n"
>             "# Ð¸Ð»Ð¸\n"
>             "# cursor.execute(\"SELECT * FROM users WHERE id = \" + user_id)\n"
>             "# Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ:\n"
>             "cursor.execute(\"SELECT * FROM users WHERE name = %s\", (name,))"
>         )
  
  
> class DangerousFunctionDetector(CSTVisitor):
>     METADATA_DEPENDENCIES = (PositionProvider,)
  
>     DANGEROUS_FUNCTIONS = {
>         "eval": "Avoid eval() â€” use ast.literal_eval for safe evaluation.",
>         "exec": "Avoid exec() â€” refactor to avoid dynamic code execution.",
>         "pickle.loads": "Avoid pickle.loads() â€” use json.loads for safe deserialization.",
>         "pickle.load": "Avoid pickle.load() â€” use json.load for safe deserialization.",
>         "jsonpickle.decode": "Avoid jsonpickle.decode() â€” use standard json module.",
>     }
  
>     def __init__(self):
>         self.vulnerabilities = []
  
>     def visit_Call(self, node: Call) -> None:
>         func = node.func
>         full_name = None
  
>         if isinstance(func, Name):
>             full_name = func.value
>         elif isinstance(func, Attribute):
>             value = func.value
>             attr = func.attr
>             if isinstance(value, Name) and isinstance(attr, Name):
>                 full_name = f"{value.value}.{attr.value}"
  
>         if full_name and full_name in self.DANGEROUS_FUNCTIONS:
>             pos = self.get_metadata(PositionProvider, node).start
>             self.vulnerabilities.append({
>                 "type": "dangerous_function",
>                 "function": full_name,
>                 "file": "current_file",
>                 "line": pos.line,
                  # ðŸ”´ ÐšÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ Ð¸ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ: Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾ Ð¿Ð¾Ð»Ðµ fix
>                 "fix": self.DANGEROUS_FUNCTIONS[full_name]
>             })
